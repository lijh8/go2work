<html>

<head>
    <style>
        /* https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme */
        :root {
            color-scheme: light dark
        }
    </style>
</head>

<body>

    <textarea disabled style="
    border: none;
    font-family: monospace;
    font-size: inherit;
    height: 100%;
    overflow-wrap: break-word;
    resize: none;
    width: 100%;">


golang install

# https://golang.google.cn/dl/ ,
# download and install

# golang mirror

$ vi ~/.profile
export PATH=$PATH:/usr/local/go/bin
go env -w GOSUMDB="sum.golang.google.cn"
go env -w GOPROXY="https://goproxy.io,https://goproxy.cn,direct"
$

$ source ~/.profile


## on macOS, the `.pkg` installer adds the path in this file
$ cat /etc/paths.d/go
/usr/local/go/bin
$


# VSCode extension: golang.go
# it installs dependencies automatically with mirror
# it prompts to install delve dlv debugger
# it works with "Remote - SSH" (ms-vscode-remote.remote-ssh) to linux

# "dlv" command is not available.
# Run "go install -v github.com/go-delve/delve/cmd/dlv@latest" to install.
Installing 3 tools at /Users/ljh/go/bin
Installing golang.org/x/tools/gopls@latest (/Users/ljh/go/bin/gopls)
Installing github.com/go-delve/delve/cmd/dlv@latest (/Users/ljh/go/bin/dlv)
Installing honnef.co/go/tools/cmd/staticcheck@latest (/Users/ljh/go/bin/staticcheck)
All tools successfully installed. You are ready to Go. :)


---


# Error loading workspace: You are outside of a module and outside of $GOPATH/src.
# should open workspace or module root directory in VSCode instead.
# these are not needed since go1.19: GOPATH, GOBIN, GOROOT, GO111MODULE.


---


$ cd ~
$ ls
cgo  go.work  foo  main
$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
.
|____main
| |____go.mod
| |____main.go
|____go.work
|____foo
| |____go.mod
| |____bar
| | |____bar.go
| |____foo.go
|____cgo
| |____Makefile
| |____cgo.c
| |____libcgo.so
| |____cgo.h
$


---


$ cd ~
$ mkdir main; cd main;
$ go mod init example/main

$ cd ~
$ mkdir foo; cd foo;
$ go mod init example/foo
$ mkdir bar

$ cd ~
$ go work init main foo
$ go work use bar  # for adding additional modules


---


$ cd ~
$ cat go.work

go 1.23.0

use (
    ./foo
    ./foo/bar
)
$

$ cat main/go.mod
module example/main

go 1.19

require foo/bar v0.0.0
replace foo/bar => ../foo/bar
$

$ cat main/main.go

package main

/*
#cgo CFLAGS: -I../cgo
#cgo LDFLAGS: -L../cgo  -lcgo
#include "cgo.h"
*/
import "C"
import (
    "example/foo"
    "example/foo/bar"
    "fmt"
    "unsafe"
)

func main() {
    fmt.Println("main")
    foo.Foo()
    bar.Bar()

    // cgo: pass strings to and from C function
    // char *strncpy2(char *dest, const char *src, size_t n);

    buf := [32]byte{}
    buflen := len(buf)
    str := "hello"
    cs := C.CString(str)
    defer C.free(unsafe.Pointer(cs))

    C.strncpy2(
        (*C.char) (unsafe.Pointer (&buf)),
        cs,
        C.size_t(buflen) - 1)

    fmt.Println("cgo", string(buf[:]))

    // cgo: pass integers to and from C function
    // int *intcpy(int *dest, int src);

    a := 0;
    b := 123;

    C.intcpy(
        (*C.int) (unsafe.Pointer(&a)),
        C.int(b))

    fmt.Println("cgo", a)
}
$


---


https://golang.google.cn/cmd/cgo/ ,

These two call malloc to make copies free them after:
C.CString, C.CBytes,


---


$ cat foo/go.mod
module example/foo

go 1.19
$

$ cat foo/foo.go
package foo

import "fmt"

func Foo() {
    fmt.Println("foo")
}
$

$ cat foo/bar/bar.go
package bar

import "fmt"

func Bar() {
    fmt.Println("bar")
}
$


---


$ cat cgo/cgo.c
#include <string.h>
#include "cgo.h"

char *strncpy2(char *dest, const char *src, size_t n)
{
    strncpy(dest, src, n);
    return dest;
}

int *intcpy(int *dest, int src)
{
    *dest = src;
    return dest;
}
$

$ cat cgo/cgo.h
#ifndef cgo_h
#define cgo_h

#include <stdio.h>
#include <stddef.h>

char *strncpy2(char *dest, const char *src, size_t n);

int *intcpy(int *dest, int src);

#endif
$

$ cat cgo/Makefile
# build shared library with -fPIC, -shared
CFLAGS   = -Wall -Wextra -g -std=c99 -fPIC # -O3  # CXXFLAGS for .cpp
LDFLAGS  = -shared # -L../foo
LDLIBS   = # -lfoo
CPPFLAGS = -MMD -MP # -I../foo
# CC     = $(CXX)  # link with CXX for .cpp

# target name is basename of one of the source files
cgo : $(patsubst %.c,%.o,$(wildcard *.c))  # .cpp
-include *.d
clean : ; -rm -fr *.o *.d
.PHONY : clean
$


---


$ cd ~/cgo
$ make
$ mv cgo libcgo.so

$ cd ~/main
$ go mod init example/foo
$ go mod tidy
$ go work init main foo
$ go work use foo
$ go run .
$ go build  # use module name from go.mod by default
$ ./main
$ go clean

$   LD_LIBRARY_PATH=../cgo/  go run .
$ DYLD_LIBRARY_PATH=../cgo/  go run .  # macOS


---


$ cd /path/to/mymodule
$ go get github.com/golang/glog  # it will modify go.mod, go.sum
$ go mod tidy  # it will modify go.sum


---


https://golang.google.cn/ref/mod ,

The go.mod file is designed to be human readable and machine writable.


---


https://go.dev/ref/spec ,

A set of files sharing the same PackageName form the implementation
of a package.

An implementation may require that all source files for a package
inhabit the same directory.


---


https://go.dev/doc/modules/layout ,

A Go package can be split into multiple files,
all residing within the same directory,
All the files in the directory declare package modname.


---


https://golang.google.cn/doc/code ,

The module contains the packages in the directory containing
its go.mod file as well as subdirectories of that directory,
up to the next subdirectory containing another go.mod file (if any).


https://golang.google.cn/doc/modules/managing-source ,

Sourcing one module per repository.
You can maintain a repository that has a single module's source in it.
In this model, you place your go.mod file at the repository root,
with package subdirectories containing Go source beneath.

Sourcing multiple modules in a single repository.
Each subdirectory that is a module root directory must have its
own go.mod file.


https://golang.google.cn/doc/modules/layout ,

Assuming this directory is uploaded to a GitHub repository
at github.com/someuser/modname, the module line in the go.mod file
should say module github.com/someuser/modname.


https://golang.google.cn/blog/using-go-modules ,

A module is a collection of Go packages stored in a file tree
with a go.mod file at its root.
The go.mod file defines the module's module path, which is also
the import path used for the root directory,
and its dependency requirements,
which are the other modules needed for a successful build.

the go command enables the use of modules when the current directory
or any parent directory has a go.mod,

the directory contains a package, but not a module,
because there is no go.mod file.

The go.mod file only appears in the root of the module.
Packages in subdirectories have import paths consisting of
the module path plus the path to the subdirectory.
For example, if we created a subdirectory world,
we would not need to (nor want to) run go mod init there.
The package would automatically be recognized as part of
the example.com/foo module, with import path example.com/foo/bar.


https://golang.google.cn/blog/migrating-to-go-modules ,

Your new go.mod file defines a canonical import path for your module,

Each module declares its module path in its go.mod file.
Each import statement that refers to a package within the module must
have the module path as a prefix of the package path.


---


https://golang.google.cn/tour/basics/1 ,
By convention, the package name is the same as the last element of
the import path.

import path consists of directories: "dir1/subdir2/subdir3".
package name and last subdir name may do not match.

import "dir_name/subdir_name" // directory name is for import
package_name.Foo() // package name is for reference exported names


---


$ cat json/go.mod
module json
go 1.23.2
$

$ cat json/main.go
package main // main executable package
// package json // non executable package

// a package in a module can be with different name as the module name;
// a package in a module can be main executable or non executable package;
// there can be only one package in module root directory;
// there can be sub module or sub package in its sub directory;
$


---


// multiple source files can be in same package;
// names from different source files in same package can be used without export;


---


package:

- all source files in a directory declare one same package name;
- subdirs are sub packages;
- go.mod turns a package into a module;
- package name is used to reference exported functions, variables or types;
- import path is "module_name";
- import path is "module_name/subdir_name" if subdir has no go.mod;


import renaming, Kernighan: 10.4:

- if package & module names do not match, use renaming;
- if package & subdir names do not match, use renaming;
    import "module_name"
    import "module_name/subdir_name" // subdir has no go.mod,
    import m "lib/math" // golang.google.cn/ref/spec, renaming,
    import package_name "module_name" // package & module name diff,
    import package_name "module_name/subdir_name" // package & subdir name diff,


module:

https://golang.google.cn/wiki/Modules#can-i-work-entirely-outside-of-vcs-on-my-local-filesystem ,

- dependencies;
- versioning;
- switch between local and online modules;


$ cat go.mod
module main
go 1.23.0
require bar v0.0.0
replace bar => ../foo/bar
require foo/bar v0.0.0
replace foo/bar => ../foo/bar
require example.com/some/dependency v1.2.3
replace example.com/some/dependency => example.com/some/dependency v1.2.3
$


workspace:

- organize multiple modules;
- use directory to module in go.work;

use (
    ./main
    ./foo
    ./foo/bar
)


---


https://go.dev/doc/modules/layout ,

A basic Go package has all its code in the project's root directory.
The project consists of a single module, which consists of
a single package.
The package name matches the last path component of the module name.

project-root-directory/
  go.mod
  modname.go
  modname_test.go

Assuming this directory is uploaded to a GitHub repository
at github.com/someuser/modname, the module line in the go.mod file
should say module github.com/someuser/modname.

The code in modname.go declares the package with:
  package modname

Users can then rely on this package by import-ing it in their
Go code with:

  import "github.com/someuser/modname"


---


The layout for a command with supporting packages in an
internal directory is very similar,
except that the file(s) in the root directory declare package main.


Multiple packages

A module can consist of multiple importable packages;
each package has its own directory, and can be structured hierarchically.

The modname package resides in the root directory,
declares package modname and can be imported by users with:
  import "github.com/someuser/modname"

Sub-packages can be imported by users as follows:
  import "github.com/someuser/modname/auth"
  import "github.com/someuser/modname/auth/token"
  import "github.com/someuser/modname/hash"


---


In Go, the versioning for modules is indeed managed by utilizing
the `go.mod` file, which includes references to other modules along with
their respective version numbers. The version number specified
in `go.mod` is commonly associated with a particular release or tag
within a version control system like Git.

When you specify a module in a `go.mod` file, you include the modules
path and the version you want to use. For example:

```go
module example.com/greetings

require example.com/somepackage v1.2.3
```

In this case, the `v1.2.3` is a version tag that specifically refers to
a release within the version control system, such as a tag in Git.
The versioning and the associated commits are managed outside of
the Go toolchain within the version control system.

So, although Go itself doesnt define the version number directly,
it relies on external version control systems like Git to manage these
versions and track the associated changes.


---


VSCode golang debugging with delve dlv:

__debug_bin: error while loading shared libraries: xxx.so:
cannot open shared object file: No such file or directory.

VSCode settings:
"go.toolsEnvVars": {
    "LD_LIBRARY_PATH": "/path/to/lib",
  "DYLD_LIBRARY_PATH": "/path/to/lib",  // macOS
},


---


# command line debug

$ ls /usr/local/go/bin/
go  gofmt
$ ls ~/go/bin/
dlv  gomodifytags  goplay  gopls  gotests  impl  staticcheck
$

$ cd ~/foo_go
$ ls
go.mod  main.go
$

https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_debug.md ,
https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_exec.md ,

$ dlv debug        # compile and debug main package in current directory

$ dlv exec ./main  # debug precompiled binary

(dlv) restart
(dlv) break main.go:57
Breakpoint 1 set at 0x49f66f for main.string_search() ./main.go:57
(dlv) breakpoints
(dlv) toggle
(dlv) clear 1
(dlv) continue
> main.string_search() ./main.go:57 (hits goroutine(1):1 total:1)
    55:
=>  57: func string_search() {
    58:    str := "aaaXXaaaYYaaa"

(dlv) print max
(dlv) next
(dlv) step
(dlv) stepout
(dlv) stack
(dlv) bt


---


https://golang.google.cn/cmd/go ,

By default, 'go run' compiles the binary without generating the
information used by debuggers, to reduce build time.
To include debugger information in the binary, use 'go build'.

$ go run -x .  # use -x to see the flags

look for the line like this in the output:
GOROOT='/usr/local/go' -o xxx/exe/main -s -w -buildmode=pie

https://golang.google.cn/doc/gdb ,


---


When debug in VSCode with extension golang.go and delve dlv debugger
and without tasks.json, the compiling is invoked before debugging,
when it fails to compile due to errors, it shows compiling flags:

go build -gcflags=all="-N -l"


---


## strip or omit debugging information, flags in ` go run -x . `
$ go build -ldflags="-s -w"

## disable optimizations, flags in compiling before F5 debugging
$ go build -gcflags=all="-N -l"


---


// https://pkg.go.dev/fmt ,
// print format

// print value and type
var i = 123
fmt.Printf("%v, %T\n", i, i)


---


// print messages with filename, line number, source location.
// set flags in package init function.

func init() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)

	log.Println()
}

/*
2024/10/08 23:29:35 a.go:9:
*/


---


// log with utc time, filename, line number,
// log to both standard output and disk file in its executable path.


package log2

func InitLog(filename string) (*os.File, error) {
    exePath, err := os.Executable()
    if err != nil {
        return nil, err
    }

    realPath, err := filepath.EvalSymlinks(exePath)
    if err != nil {
        return nil, err
    }

    logpath := filepath.Dir(realPath)
    logpath = filepath.Join(logpath, filename)
    logfd, err := os.OpenFile(logpath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return nil, err
    }
    multiWriter := io.MultiWriter(logfd, os.Stdout)
    log.SetOutput(multiWriter)
    log.SetPrefix("UTC ")
    log.SetFlags(log.LUTC | log.LstdFlags | log.Lshortfile)
    return logfd, nil
}

/*
func main() {
    logfile := "logfile.log"
    logfd, err := log2.InitLog(logfile) // log2 init
    if err == nil {
        defer logfd.Close()
    }

    log.Println("aaa") // log as usual
    log.Println("bbb")
}
*/


---


// golang print log filename, line number, function name

func Println2(args ...any) {
    pc, file, line, ok := runtime.Caller(1)
    if !ok {
        file, line = "unknown", 0
    }
    fn := runtime.FuncForPC(pc)
    fmt.Println(append([]any{filepath.Base(file), ":", line, ":", fn.Name(), ":"}, args...)...)
}

func main() {
    fmt.Println("aaa", 111)
    println("bbb", 222)
}


---


type T struct {
    num int
}

// non-interface:

// method can take value of pointer receiver
// receiver can be value of pointer
// pointer receiver can write changes to receiver

//func (t *T) f1() {
func (t T) f1() {
    t.num *= 2
}


// interface:

// receiver must match
// value receiver takes value receiver
// pointer receiver takes pointer receiver
// pointer receiver can write changes to receiver

type I2 interface {
    f2()
}

type I3 interface {
    f3()
}

func (t T) f2() {
    t.num *= 2
}

func (t *T) f3() {
    t.num *= 2
}

func main() {
    t := T{2}
    t.f1()
    println(t)

    p := &T{2}
    p.f1()
    println(p)

    var i2 I2 = T{2}
    i2.f2()
    println(i2)

    var i3 I3 = &T{2}
    i3.f3()
    println(i3)
}


---


example 1:

// https://golang.google.cn/tour/concurrency/5 ,

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func read(c, quit chan int) {
    for i := 0; i < 5; i++ {
        fmt.Println(<-c)
    }
    quit <- 0
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go read(c, quit)
    fibonacci(c, quit)
}


example 2:

// https://golang.google.cn/tour/concurrency/5 ,

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func read(c, quit chan int) {
    for i := 0; i < 5; i++ {
        fmt.Println(<-c)
    }
    quit <- 0
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go fibonacci(c, quit)
    read(c, quit)
}


---


// Common Mistakes

func main() {
    fun1()
    fun2()
}


// https://github.com/golang/go/wiki/CommonMistakes ,
// Using reference to loop iterator variable

func fun1() {
    var out []*int
    for i := 0; i < 3; i++ {
        i := i //add new variable
        out = append(out, &i)
    }
    fmt.Println("Values:", *out[0], *out[1], *out[2])
    fmt.Println("Addresses:", out[0], out[1], out[2])
}


// https://golang.google.cn/doc/faq ,
// What happens with closures running as goroutines?

func fun2() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func(v string) { //add parameter
            fmt.Println(v)
            done <- true
        }(v) //pass argument
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}


---


func main() {
    for i := 0; i < 3; i++ {

        // https://go.dev/wiki/CommonMistakes ,
        // Using reference to loop iterator variable ,
        // Fixed in: https://golang.google.cn/blog/loopvar-preview ,

        // i := i // Copy i into a new variable, not anymore, Fixed in 1.22,

        println(i)
    }

    // https://go.dev/wiki/CommonMistakes ,
    // Using goroutines on loop iterator variables ,
    // Fixed in: https://golang.google.cn/blog/loopvar-preview ,

    values := []int{1, 2, 3}

    // it is a bug before 1.22, works since 1.22,
    for _, val := range values {
        func() {
            println(val)
        }()
    }

    // temporary fix before 1.22, not anymore, Fixed in 1.22,
    for _, val := range values {
        func(val interface{}) { // val, not anymore, Fixed in 1.22,
            println(val)
        }(val) // val, not anymore. Fixed
    }
}


---


// https://golang.google.cn/doc/effective_go#redeclaration ,

// Redeclaration and reassignment

// there is at least one new other variable that is
// created by the declaration.
// this unusual property is pure pragmatism,
// making it easy to use a single err value.

func main() {
    a, err := strconv.Atoi("123")
    if err == nil {
        println(a);
    }

    // there is at least a new other variables `b` on left side of :=
    b, err := strconv.Atoi("123")
    if err == nil {
        println(b);
    }
}


https://golang.google.cn/doc/effective_go#composite_literals ,

// Constructors and composite literals

unlike in C, it's perfectly OK to return the address of a local variable;
the storage associated with the variable survives after the
function returns.

return &File{fd: fd, name: name}


---


// golang read text file line by line ,

func main() {
    // Open the text file
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    // Create a new Scanner to read from the file
    scanner := bufio.NewScanner(file)

    // Read the file line by line
    for scanner.Scan() {
        line := scanner.Text()
        fmt.Println(line)
    }

    // Check for any errors during scanning
    if err := scanner.Err(); err != nil {
        fmt.Println("Error scanning file:", err)
    }
}


---


// command line arguments

func main() {

    argsWithProg := os.Args
    argsWithoutProg := os.Args[1:]

    arg := os.Args[3]

    fmt.Println(argsWithProg)
    fmt.Println(argsWithoutProg)
    fmt.Println(arg)
}


// standard input and output

func main() {
    reader := bufio.NewReader(os.Stdin)
    writer := bufio.NewWriter(os.Stdout)

    n, err := writer.WriteString("Enter a line: ")
    if err != nil {
        fmt.Println(err, n)
        return
    }
    writer.Flush()

    line, err := reader.ReadString('\n')
    if err != nil {
        fmt.Println(err, line)
        return
    }

    msg := fmt.Sprintf("You entered: %s\n", line)
    n, err = writer.WriteString(msg)
    if err != nil {
        fmt.Println(err, n)
        return
    }
    writer.Flush()
}


---


// https://golang.google.cn/pkg/strings/#Index ,
// strings.Index for substring or single character ,

// Index returns the index of the first instance of substr in s,
// or -1 if substr is not present in s.

func main() {
    fmt.Println(strings.Index("chicken", "ken"))
    fmt.Println(strings.Index("chicken", "dmr"))
}

func main() {
    fmt.Println(strings.Index("chicken", "dmr"))
    fmt.Println(strings.Index("chicken", "ken"))
    fmt.Println(strings.Index("chicken"[4:], "ken")) // search in range
    fmt.Println(strings.Index("chicken"[4:5], "ken")) // search in range
    fmt.Println(strings.Index("chicken"[5:], "ken")) // search in range
}


// https://golang.google.cn/pkg/slices/#Index ,
// slices.Index for single element,
// slices.Sort,
// slices.BinarySearch,

func Index[S ~[]E, E comparable](s S, v E) int
Index returns the index of the first occurrence of v in s,
or -1 if not present.

(v in s, value in slice)

func main() {
    numbers := []int{0, 123, 8}
    fmt.Println(slices.Index(numbers, 8))
    fmt.Println(slices.Index(numbers, 7))
}

func main() {
    numbers := []int{0, 123, 8, 10, 20}
    fmt.Println(slices.Index(numbers, 8))
    fmt.Println(slices.Index(numbers[3:], 8)) // search in range
    fmt.Println(slices.Index(numbers[:2], 8)) // search in range
}


// https://golang.google.cn/pkg/slices/#IndexFunc ,
IndexFunc returns the first index i satisfying f(s[i]), or -1 if none do.

func main() {
    numbers := []int{0, 123, -10, 8}
    i := slices.IndexFunc(numbers, func(n int) bool {
        return n < 0
    })
    fmt.Println("First negative at index", i)
}


// strings.LastIndex equivalent for slices
func LastIndex[S ~[]E, E comparable](s S, v E) int {
    for i := len(s) - 1; i >= 0; i-- {
        if s[i] == v {
            return i
        }
    }
    return -1
}


---


// search find substring, strstr(3)

func main() {
    haystack := "helloworld"
    needle := "l"

    func(s string) {
        for i, j := 0, 0; i < len(s); i += j + 1 {
            if j = strings.Index(s[i:], needle); j == -1 {
                return
            }
            print(i+j, " ")
        }
    }(haystack)
    println()

    func(s string) {
        for i := len(s); i > 0; {
            if i = strings.LastIndex(s[:i], needle); i != -1 {
                print(i, " ")
            }
        }
    }(haystack)
    println()
}


---


// https://golang.google.cn/pkg/slices/#Sort ,

func main() {
    smallInts := []int8{0, 123, -10, 8}
    slices.Sort(smallInts)
    fmt.Println(smallInts)
}


// https://golang.google.cn/pkg/slices/#SortFunc ,
// Example (MultiField)

func main() {
    type Person struct {
        Name string
        Age  int
    }
    people := []Person{
        {"Gopher", 13},
        {"Alice", 55},
        {"Bob", 24},
        {"Alice", 20},
    }
    slices.SortFunc(people, func(a, b Person) int {
        if n := cmp.Compare(a.Name, b.Name); n != 0 {
            return n
        }
        // If names are equal, order by age
        return cmp.Compare(a.Age, b.Age)
    })
    fmt.Println(people)
}


// https://golang.google.cn/pkg/slices/#BinarySearch ,
The slice must be sorted in increasing order ,

func main() {
    names := []string{"Alice", "Bob", "Vera"}
    n, found := slices.BinarySearch(names, "Vera")
    fmt.Println("Vera:", n, found)
    n, found = slices.BinarySearch(names, "Bill")
    fmt.Println("Bill:", n, found)
}


// https://golang.google.cn/pkg/slices/#BinarySearchFunc ,
The slice must be sorted in increasing order ,

func main() {
    type Person struct {
        Name string
        Age  int
    }
    people := []Person{
        {"Alice", 55},
        {"Bob", 24},
        {"Gopher", 13},
    }
    n, found := slices.BinarySearchFunc(people, Person{"Bob", 0}, func(a, b Person) int {
        return cmp.Compare(a.Name, b.Name)
    })
    fmt.Println("Bob:", n, found)
}


---


https://go.dev/blog/slices-intro#growing-slices-the-copy-and-append-functions ,
Growing slices (the copy and append functions)

To increase the capacity of a slice one must create a new,
larger slice and copy the contents of the original slice into it.
This technique is how dynamic array implementations from other languages
work behind the scenes. The next example doubles the capacity of s by
making a new slice, t, copying the contents of s into t,
and then assigning the slice value t to s


---


https://go.dev/ref/spec ,

The iteration order over maps is not specified and is not guaranteed to
be the same from one iteration to the next.

https://go.dev/blog/maps#iteration-order ,

Iteration order

When iterating over a map with a range loop, the iteration order is not
specified and is not guaranteed to be the same from one iteration to the
next. If you require a stable iteration order you must maintain a
separate data structure that specifies that order. This example uses a
separate sorted slice of keys to print a map[int]string in key order:

var m map[int]string
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println("Key:", k, "Value:", m[k])
}


---


// check integer overflow underflow wrap around

func main() {
    // MaxUint64:18446744073709551615,
    // MaxInt64 : 9223372036854775807,
    // MinInt64 :-9223372036854775808,

    var a uint64 = 18446744073709551615
    var b int64 =   9223372036854775807
    var c int64 =  -9223372036854775808
    var incr = 1 // 10

    // a -= 1 // a--
    if math.MaxUint64 - a < uint64(incr) {
        fmt.Println("err: a too large", a + uint64(incr))
    }

    // b -= 1 // b--
    if math.MaxInt64 - b < int64(incr) {
        fmt.Println("err: b too large", b + int64(incr))
    }

    // c += 1 // c++
    if math.MinInt64 + int64(incr) > c {
        fmt.Println("err: c too little", c - int64(incr))
    }
}


---


// /usr/local/go/src/builtin/builtin.go
type error interface {
    Error() string
}

// /usr/local/go/src/errors/errors.go
func New(text string) error {
    return &errorString{text} // ok

    // return errorString{text} // error

    // cannot use errorString{…} (value of type errorString) as error value in return statement:
    // errorString does not implement error (method Error has pointer receiver)
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}


---


// https://github.com/golang/vscode-go/wiki/debugging ,
// .vscode/launch.json

{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug",
            "type": "go",
            "request": "launch",
            "mode": "debug", // main package
            "program": "${fileDirname}", // main package
            // "mode": "exec", // executable
            // "program": "${fileDirname}/${fileBasenameNoExtension}", // executable
            "args": [], //
            // "args": ["12345"], // $ ./server <port>
            // "args": ["192.168.1.3", "12345", "clientABC"], // $ ./client <serverIP> <port> <clientTag>
            "env": {
                "LD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
                "DYLD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
            },
            "cwd": "${fileDirname}",
            "console": "integratedTerminal",
            "preLaunchTask": "debugTask",
        },

        {
            "name": "Release",
            "type": "go",
            "request": "launch",
            "mode": "debug", // main package
            "program": "${fileDirname}", // main package
            // "mode": "exec", // executable
            // "program": "${fileDirname}/${fileBasenameNoExtension}", // executable
            "args": [], //
            // "args": ["12345"], // $ ./server <port>
            // "args": ["192.168.1.3", "12345", "clientABC"], // $ ./client <serverIP> <port> <clientTag>
            "env": {
                "LD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
                "DYLD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
            },
            "cwd": "${fileDirname}",
            "console": "integratedTerminal",
            "preLaunchTask": "releaseTask",
        }
    ]
}

// https://code.visualstudio.com/Docs/editor/tasks ,
// .vscode/tasks.json

{
    "tasks": [
        {
            "type": "shell",
            "label": "debugTask",
            "command": "go",
            "args": ["build", "-gcflags=all=-N -l"], // disable optimizations
            // "args": ["build"],
            // "args": ["build", "-ldflags=-s -w"], // strip or omit the debug information
            "options": {
                // "cwd": "${workspaceFolder}/src",
                "cwd": "${fileDirname}",
            },
        },

        {
            "type": "shell",
            "label": "releaseTask",
            "command": "go",
            // "args": ["build", "-gcflags=all=-N -l"], // disable optimizations
            // "args": ["build"],
            "args": ["build", "-ldflags=-s -w"], // strip or omit the debug information
            "options": {
                // "cwd": "${workspaceFolder}/src",
                "cwd": "${fileDirname}",
            },
        }
    ],
    "version": "2.0.0",
}


---


// slice, array, string,

func main() {
    {
        // array are numbered contiguous sequence of elements.
        // slice is a segment of sub sequence of an array.

        a := [3]int{1, 2, 3}
        b := a[:] // ok, arry to slice
        b[0] = 100
        fmt.Println(a, b)
    }

    {
        // string is immutable like the string literal in c language.
        // char []a = "hello";

        // to modify character elements in string,
        // it needs a type conversion to slice explicitly.

        // string type may be implemented with a struct,
        // so it needs explicit conversion.
        // this is not like array to slice.

        a := "abc"
        b := []rune(a) // ok, string to slice,
        b[0] = 'A'
        fmt.Println(a, string(b))
    }
}


---


// imitating tuple in golang

package tuple2

import (
    "cmp"
    "reflect"
)

func Compare(a, b []any) (int, bool) {
    if len(a) != len(b) {
        return 0, false
    }

    for i := range a {
        if a[i] == nil || b[i] == nil {
            return 0, false
        }

        if _, boolean := a[i].(bool); boolean {
            return 0, false
        }
        if _, boolean := b[i].(bool); boolean {
            return 0, false
        }

        if a, b := reflect.TypeOf(a[i]), reflect.TypeOf(b[i]); a != b {
            return 0, false
        }

        if a, aOk := a[i].(string); aOk {
            if b, bOk := b[i].(string); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].(int); aOk {
            if b, bOk := b[i].(int); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].(float64); aOk {
            if b, bOk := b[i].(float64); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].([]any); aOk {
            if b, bOk := b[i].([]any); bOk {
                if c, ok := Compare(a, b); ok && c != 0 {
                    return c, true
                } else if !ok {
                    return 0, false
                }
            }
        }
    }
    return 0, true
}

/*
func main() {
    a := []any{"abc", 123, 3.14}
    b := []any{"abc", 123, 3.14}
    c, ok := tuple2.Compare(a, b)
    fmt.Println(c, ok)
}
*/


---


In VSCode with golang.go extension, start compiling and debugging
with F5, but without launch.json, tasks.json, when build fails,
the go build command and flags show in console or terminal.

Build Error: go build -o /path/__debug_bin3374052179 -gcflags all=-N -l .
./main.go:13:30: syntax error: xxx;


---


error: no new variables on left side of := ,
reason:
    see this error when variable name is same as parameter name.

warning: func aCmp222 is unused (U1000) ,
reason:
    function name starts with lower case,
    it is not used in other exported function in same package,
    it also has no chance to be used outside the package,
    because its name starts with lower case.


---


// builtin print can not handle data of interface type,
// fmt.Println can help,
// log to disk file with log.Println,

var a any = "aaa"
va := reflect.ValueOf(a)
println(va) // illegal types for operand: print, reflect.Value (compile)
fmt.Println(va)


---


// generics

// concrete type as type constraint for type parameter
func f1[T string](name T) {

}

// ~T means all types whose underlying type is string
func f2[T ~string](name T) {

}

// T | T  means union type set
func f3[T ~string | ~int | float64](name T) {

}

func main() {
    f1("abc")
    f2("abc")

    f3("abc")
    f3(123)
}


---


func main() {
    ch := make(chan int, 3)
    done := make(chan struct{})

    //sending
    var sending = func() {
        for i := 0; i <= 5; i++ {
            select {
            case ch <- i:
                fmt.Printf("sending:%d, ", i)
            default:
                // block on buffered channel is full, unless there is a receiver
                fmt.Printf("blocking, len:%d, cap:%d, ", len(ch), cap(ch))
            }
        }

        close(ch) // for range statement in receiver
        done <- struct{}{} // for synchronization
    }

    //receiving
    var receiving = func() {
        // turn of this range loop to see the block when channel is full
        /*
        for i := range ch { // receiving, same as: <-ch
            fmt.Printf("receiving, ch:%d, len:%d, cap:%d, ", i, len(ch), cap(ch))
        }
        */

        done <- struct{}{} // for synchronization
    }

    go sending()
    go receiving()

    <-done // wait for sending background goroutine
    <-done // wait for receiving background goroutine
}


---


func main() {
    const MAX = 3
    done := make(chan any)

    go func() {
        for i := 0; i != MAX; i++ {
            fmt.Printf("func1:%d, ", i)
        }
        done <- nil
    }()

    go func() {
        for i := 0; i != MAX; i++ {
            fmt.Printf("func2:%d, ", i)
        }
        done <- nil
    }()

    for i := 0; i != MAX; i++ {
        fmt.Printf("main:%d, ", i)
    }

    // do synchronization and wait for background goroutine

    <-done // one for background goroutine func1
    <-done // one for background goroutine func2
}


---


A Tour of Go:
https://golang.google.cn/tour/concurrency/2 ,

Channel communication:
https://golang.google.cn/ref/mem ,


By default, sends and receives block until the other side is ready.
This allows goroutines to synchronize without explicit locks or
condition variables.

https://golang.google.cn/tour/concurrency/3 ,

Sends to a buffered channel block only when the buffer is full.
Receives block when the buffer is empty.


---


The Go Memory Model:

Channel communication,

https://golang.google.cn/ref/mem ,

1. A send on a channel is synchronized before the completion of the
    corresponding receive from that channel.

2. A receive from an unbuffered channel is synchronized before the
    completion of the corresponding send on that channel.

3. The closing of a channel is synchronized before a receive that
    returns a zero value because the channel is closed.

4. The kth receive on a channel with capacity C is synchronized before
    the completion of the k+Cth send from that channel completes.


explanation:

https://golang.google.cn/tour/concurrency/2 ,

1,2: for unbuffered channel:
    Send/Receive will block until a correspoding Receive/Send.

4: for buffered channel:
    Send will block when the channel is full,
    Receive will block when the channel is empty.

---


1. for unbuffered and buffered channel,
    a send blocks the current goroutine;
    A send operation establishes a happens-before relationship with the
    corresponding receive operation in terms of memory visibility.
    This means that the send must occur before the receive for the value
    to be seen on the channel, regardless of whether the channel is
    buffered or unbuffered.

2. for unbuffered channel, a receive also blocks the current goroutine;
    An unbuffered channel has a size and capacity of zero,
    meaning it has no buffer to store values.
    Communication over an unbuffered channel is synchronous,
    requiring both the send and receive goroutines to be ready
    simultaneously for data transfer to occur.

3. range and close, https://golang.google.cn/tour/concurrency/4 ,
    Closing is only necessary when the receiver must be told there are
    no more values coming, such as to terminate a range loop.

4. A buffered channel is of capacity of ie. 3, if send four values to it,
    the channel is full, the forth send will blocks and waits for a
    receive before it. if there is no corresponding receive,
    it is deadlock and it panics.

    send to full buffered channel causes deadlock;
    receive from empty bufferec channel causes deadlock;

    A send places a value into buffered channel;
    A receive removes a value from buffered channel;


---


Unbuffered Channels:
Ensure direct synchronization between sends and receives,
each send blocks until it is matched with a receive.

Buffered Channels:
Allow multiple sends up to capacity without immediate receives,
but will block when the buffer is full until a receive frees up space.


---


The Go Programming Language, by Kernighan & Donovan,


2.3.4:
A compiler may choose to allocate local variables on
the heap or on the stack but, perhaps sur- prisingly,
this choice is not determined by whether var or new was used to
declare the variable.

    var global *int
    func f() {
        var x int
        x = 1
        global = &x // return the address of a local variable
    }

Here, x must be heap-allocated because it is still reachable
from the variable global after f has returned,
despite being declared as a local variable; we say x escapes from f.

keeping unnecessary pointers to short-lived objects within long-lived
objects, especially global variables, will prevent the garbage collector
from reclaiming the short-lived objects.


2.6.1:
an import path denotes a directory containing one or more Go source
files that together make up the package.

By convention, a package’s name matches the last segment of its
import path, making it easy to predict that the package name
of gopl.io/ch2/tempconv is tempconv.

# if the last sub directory and the package name do not match
(are not the same)
import directory_name/subdir_name  #
package_name.Foo #

# if the last sub directory and the package name match (they are same)
import directory_name/foo  #
foo.Foo #

// see 10.4: renaming, alternative name mrand avoids conflict
import mrand "math/rand"


5.6:
The anonymous inner function can access and update the local variables
of the enclosing function. These hidden variable references are why we
classify functions as reference types and why function values are
not comparable.


8.4:
Channels support a third operation, close, which sets a flag indicating
that no more values will ever be sent on this channel; subsequent
attempts to send will panic. Receive operations on a


8.4.1:
A send operation on an unbuffered channel blocks the sending goroutine
until another goroutine executes a corresponding receive on the same
channel, at which point the value is transmitted and both goroutines may
continue.

Conversely, if the receive operation was attempted first, the
receiving goroutine is blocked until another goroutine performs a send
on the same channel.


8.4.4:
Unbuffered channels give stronger synchronization guarantees because
every send operation is synchronized with its corresponding receive;


10.4:

import (
    "crypto/rand"
    mrand "math/rand" // alternative name mrand avoids conflict
)


---


https://golang.google.cn/ref/mem ,

// A send on a channel is synchronized before the completion of the
// corresponding receive from that channel.

// var c = make(chan int, 10) // buffered, ok
var c = make(chan int) // unbuffered, ok
var a string

func f() {
    a = "hello, world"
    c <- 0
}

func main() {
    go f()
    <-c
    print(a)
}

// is guaranteed to print "hello, world".
// The write to a is sequenced before the send on c,
// which is synchronized before the corresponding receive on c completes,
// which is sequenced before the print.


---


https://golang.google.cn/ref/mem ,

// A receive from an unbuffered channel is synchronized before the
// completion of the corresponding send on that channel.

// original

var c = make(chan int)
var a string

func f() {
    a = "hello, world"
    <-c
}

func main() {
    go f()
    c <- 0
    print(a)
}

// revised

// var c = make(chan int)     // ok
var c = make(chan int, 10) // no, buffered
var a string
var done chan any = make(chan any)

func f() {
    a = "hello, world"

    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c

    done <- nil
}

func main() {
    go f()
    c <- 0
    c <- 0 // try to send one more, and see len in f()

    <-done // send to this in f() happends before this line

    print(a)

}

// output:
// len: 2 , cap: 10
// hello, world

1. send to c in main() is sequenced before receive in f(),
    so len(c) in f() reports count of values sent in main().

2. add channel `done` and send to it in f(),
    to make sure the assignment to a happens before main().


---


https://golang.google.cn/ref/mem ,

// The kth receive on a channel with capacity C is synchronized before
// the completion of the k+Cth send from that channel completes.

// var c = make(chan int)
var c = make(chan int, 3)
var a string

func f() {
    a = "hello, world"
    <-c
}

func main() {
    go f()
    c <- 0
    c <- 0
    c <- 0

    // this send is beyond cap(c),
    // it blocks and waits for a receive before it.
    c <- 0

    print(a)
}


---


// fatal error: all goroutines are asleep - deadlock!
// goroutine 1 [chan receive]:

/*
the term "asleep" is synonymous with "blocked" or "waiting indefinitely."
Specifically, it means that all active goroutines in the program are
waiting for something that will never happen, leading to a deadlock.

golang panics and terminates program explicitly,
let programmer to identify the issue.
*/

var c = make(chan int, 3)
var a string
var done = make(chan any)

func f() {
    a = "hello, world"
    println(<-c, len(c), cap(c))
    println(<-c, len(c), cap(c)) // error, receive from empty channel

    done <- nil
}

func main() {
    go f()
    c <- 20

    <-done

    print(a)
}


---


// fatal error: all goroutines are asleep - deadlock!
// goroutine 1 [chan send]:

var c = make(chan int, 3)
var a string
var done = make(chan any)

func f() {
    a = "hello, world"
    <-c

    done <- nil
}

func main() {
    go f()
    c <- 0
    c <- 0
    c <- 0
    c <- 0
    c <- 0 // error, send to full buffered channel

    <-done

    print(a)
}


---


// modification

// var c = make(chan int) // ok
var c = make(chan int, 10) // no, buffered
var a string

var done chan any = make(chan any)

func f() {
    a = "hello, world"

    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c

    done <- nil
}

func main() {
    go f()
    // c <- 0 // try comment out this line

    <-done

    print(a)

}

// try commenting all sends to c in main(),
// add channel `done` and send to it in f(),
// the receive from c in f() causes deadlock, because c is empty.


---


// modification, again

// var c = make(chan int) // ok
var c = make(chan int, 10) // no, buffered
var a string

var done chan any = make(chan any)

func f() {
    a = "hello, world"
    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c
    done <- nil
}

func main() {
    go f()
    <-done
    c <- 0 // try comment out this line
    print(a)

}

// try move ` <-done ` before ` <-c ` in main() to see deadlock


---


func main() {
    // synchronize two goroutines with two channels
    // let the code in the first goroutine execute first
    const MAX = 6
    cA := make(chan any)
    cB := make(chan any)
    done := make(chan any)

    go func() {
        for i := 0; i < MAX; i++ {
            fmt.Println("a", i)
            cA <- nil
            <-cB
        }
        done <- nil
    }()

    go func() {
        for i := 0; i < MAX; i++ {
            <-cA
            fmt.Println("b", i)
            cB <- nil
        }
        done <- nil
    }()

    -, - = <-done, <-done
}

func main() {
    // synchronize two goroutines with two channels
    // let the code in the second goroutine execute first
    const MAX = 6
    cA := make(chan any)
    cB := make(chan any)
    done := make(chan any)

    go func() {
        for i := 0; i < MAX; i++ {
            <-cA
            fmt.Println("a", i)
            cB <- nil
        }
        done <- nil
    }()

    go func() {
        for i := 0; i < MAX; i++ {
            fmt.Println("b", i)
            cA <- nil
            <-cB
        }
        done <- nil
    }()

    <-done
    <-done
}


---


func main() {
    const CAP = 3 // unbuffered: 0; buffered: 1,2,3,.., etc.
    const LEN = CAP + 2
    ch := make(chan any, CAP)
    done := make(chan any)

    go func() {
        for i := 0; i < LEN; i++ {
            select {
            case ch <- nil: // comment this to see block on empty
            // case <-ch: // comment this to see block on full
            default:
                log.Printf("block, i:%d, len:%d; cap:%d", i, len(ch), cap(ch))
            }
        }
        done <- nil
    }()

    <-done
}


---


// garbage collection, heap size, gc pause,

$ GODEBUG=gctrace=1 go run .
gc 1 @0.037s 2%: 0.083+1.5+0.050 ms clock, 0.33+2.5/1.2/0+0.20 ms cpu, 3->3->0 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 4 P
gc 2 @0.166s 1%: 0.35+3.4+0.024 ms clock, 1.4+0.10/3.1/2.6+0.097 ms cpu, 3->3->1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 4 P
gc 3 @0.220s 1%: 0.29+1.4+0.009 ms clock, 1.1+0.41/1.2/1.1+0.037 ms cpu, 3->3->1 MB, 4 MB goal, 0 MB stacks, 0 MB globals, 4 P
# main
gc 1 @0.003s 6%: 0.024+5.4+0.035 ms clock, 0.096+1.1/1.0/4.0+0.14 ms cpu, 5->5->4 MB, 5 MB goal, 0 MB stacks, 0 MB globals, 4 P
gc 2 @0.041s 2%: 0.011+0.84+0.056 ms clock, 0.045+0.13/0.69/0.71+0.22 ms cpu, 9->9->8 MB, 9 MB goal, 0 MB stacks, 0 MB globals, 4 P
gc 3 @0.404s 0%: 0.046+1.8+0.029 ms clock, 0.18+0/0.98/2.5+0.11 ms cpu, 16->16->9 MB, 16 MB goal, 0 MB stacks, 0 MB globals, 4 P


---


go pprof:
https://golang.google.cn/pkg/runtime/pprof ,

To add equivalent profiling support to a standalone program,
add code like the following to your main function:

var cpuprofile = flag.String("cpuprofile", "", "write cpu profile to `file`")
var memprofile = flag.String("memprofile", "", "write memory profile to `file`")

func main() {
    flag.Parse()
    if *cpuprofile != "" {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            log.Fatal("could not create CPU profile: ", err)
        }
        defer f.Close() // error handling omitted for example
        if err := pprof.StartCPUProfile(f); err != nil {
            log.Fatal("could not start CPU profile: ", err)
        }
        defer pprof.StopCPUProfile()
    }

    // ... rest of the program ...

    if *memprofile != "" {
        f, err := os.Create(*memprofile)
        if err != nil {
            log.Fatal("could not create memory profile: ", err)
        }
        defer f.Close() // error handling omitted for example
        runtime.GC() // get up-to-date statistics
        if err := pprof.WriteHeapProfile(f); err != nil {
            log.Fatal("could not write memory profile: ", err)
        }
    }
}

$ go test -cpuprofile cpu.prof -memprofile mem.prof -bench .
$ go tool pprof cpu.prof


---


go tool trace:
https://golang.google.cn/cmd/trace ,

$ go test -trace trace.out pkg
$ go tool trace trace.out
$ go tool trace -pprof=TYPE trace.out > TYPE.pprof

Supported profile types are:
    net: network blocking profile
    sync: synchronization blocking profile
    syscall: syscall blocking profile
    sched: scheduler latency profile

$ go tool pprof TYPE.pprof


---


https://golang.google.cn/cmd/go ,

The following flags are also recognized by 'go test' and can be used
to profile the tests during execution:

-benchmem
-coverprofile cover.out
-cpuprofile cpu.out
-memprofile mem.out
-trace trace.out

Profiling: is a technique used to measure how much CPU time or memory is
consumed by various parts of a program during its execution.

Tracing: involves recording detailed information about the execution of
a program over time.


---


// https://golang.google.cn/doc/effective_go ,
// In Go, function literals are closures:
// the implementation makes sure the variables referred to by the
// function survive as long as they are active.

// Kernighan: 5.6,
// The anonymous inner function can access and update the local
// variables of the enclosing function. These hidden variable references
// are why we classify functions as reference types and why function
// values are not comparable.

// outer variable is used or assigned in inner closure,
// like outer variable is used or assigned in inner scope.

func main() {
    a := 10
    func() {
        a++
    }()
    println(a) // 11
}


// if a closure captures outer variables and it is return value of a
// function, when the function returns with the closure, the closure
// still captures the outer variables by address (or by reference),
// the captured variables escape from its function stack and
// will be allocated in heap and managed by garbage collection.

func increment() func() int {
    x := 0
    return func() int {
        x++
        return x
    }
}

func main() {
    incr := increment()
    println(incr())
    println(incr())
    println(incr())
}


---


Range Over Function Types, rangefunc,
https://go.dev/wiki/RangefuncExperiment ,
https://golang.google.cn/blog/range-functions#forrange ,
https://golang.google.cn/blog/range-functions#standard-push-iterators ,

for some sequence of values, they call a yield function with each value
in the sequence. If the yield function returns false, no more values
are needed, and the iterator can just return, doing any cleanup that may
be required. If the yield function never returns false, the iterator can
just return after calling yield with all the values in the sequence.

call yield with every element of the set,
stopping if yield returns false.


// in this example, the loop exits when the sequence is completed,
// not because yield returns false.
// The yield function would only return false to exit early if there was
// a specific reason to stop processing the sequence before
// it naturally ends.

// func Countdown(v int) func(func(int) bool) { // without iter
func Countdown(v int) iter.Seq[int] { // with iter
    return func(yield func(int) bool) {
        for i := v; i >= 1; i-- {
            if !yield(i) {
                break
            }
        }
    }
}

// func DemoSeq2[T any](s []T) func(func(int, T) bool) { // without iter
func DemoSeq2[T any](s []T) iter.Seq2[int, T] { // with iter
    return func(yield func(int, T) bool) {
        for i, v := range s {
            if !yield(i, v) {
                break
            }
        }
    }
}

func main() {
    n := 3
    for x := range Countdown(n) {
        println(x)
    }

    s := []string{"aaa", "bbb", "ccc"}
    for i, v := range DemoSeq2(s) {
        println(i, v)
    }
}

// output:
// 3
// 2
// 1
// 0 aaa
// 1 bbb
// 2 ccc


---


// func Countdown(v int) func(func(int) bool) { // without iter package
func Countdown(v int) iter.Seq[int] { // with iter package
    return func(yield func(int) bool) {
        for i := v; i >= 1; i-- {
            if !yield(i) {
                break
            }
        }
    }
}

// yield returning false and early exit
func main() {
    n := 5
    value := 3
    found := false
    for x := range Countdown(n) {
        if x == value {
            found = true
            break // this make the yield return false and exit early
        }
    }
    println(found)
}


---


type Yield[V any] func(V) bool
type Yield2[K comparable, V any] func(K, V) bool
type Seq[V any] func(Yield[V])
type Seq2[K comparable, V any] func(Yield2[K, V])

func sliceDemo[K int, V any](s []V) Seq2[K, V] {
    return func(yield Yield2[K, V]) {
        for i, v := range s {
            if !yield(K(i), v) {
                break
            }
        }
    }
}

func mapDemo[K comparable, V any](s map[K]V) Seq2[K, V] {
    return func(yield Yield2[K, V]) {
        for i, v := range s {
            if !yield(i, v) {
                break
            }
        }
    }
}

func main() {
    s := []string{"aaa", "bbb", "ccc"}
    for i, v := range sliceDemo(s) {
        println(i, v)
    }

    m := map[string]int{"aaa": 10, "bbb": 20, "ccc": 30}
    for i, v := range mapDemo(m) {
        println(i, v)
    }
}


---


// standard push iterator
func Countdown(v int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := v; i >= 1; i-- {
            if !yield(i) {
                break
            }
        }
    }
}

func main() {
    n := 3
    for x := range Countdown(n) {
        println(x)
    }
}


// https://golang.google.cn/blog/range-functions#pull-iterators ,
// Pull iterators are not supported directly by the for/range statement;
// It is straightforward to write an ordinary for statement that loops
// through a pull iterator.

// pull iterator
func CountdownPull(v int) func() (int, bool) {
    current := v
    return func() (int, bool) {
        if current > 0 {
            val := current
            current--
            return val, true
        }
        return 0, false
    }
}

func main() {
    n := 3
    // Create the pull iterator
    next := CountdownPull(n)

    // Use the pull iterator
    for {
        val, ok := next()
        if !ok {
            break
        }
        println(val)
    }
}


---


// iterator function,

Range Over Function Types,
https://golang.google.cn/blog/range-functions ,

We also added standard library types and functions to support using
function types as iterators. A standard definition of iterators lets us
write functions that work smoothly with different container types.

As of Go 1.23 it now supports ranging over functions that take a single
argument. The single argument must itself be a function that takes zero
to two arguments and returns a bool; by convention, we call it the
yield function.

func(yield func() bool)
func(yield func(V) bool)
func(yield func(K, V) bool)

When we speak of an iterator in Go, we mean a function with one of
these three types.

To make iterators easier to use, the new standard library package iter
defines two types: Seq and Seq2. These are names for the iterator
function types, the types that can be used with the for/range
statement. The name Seq is short for sequence, as iterators loop
through a sequence of values.

// /usr/local/go/src/iter/iter.go
type Seq[V any]     func(yield func(V) bool)
type Seq2[K, V any] func(yield func(K, V) bool)


The return type of All is iter.Seq[E], so we know that it returns an
iterator.

// All is an iterator over the elements of s.
func (s *Set[E]) All() iter.Seq[E] {
    return func(yield func(E) bool) {
        for v := range s.m {
            if !yield(v) {
                return
            }
        }
    }
}

The iterator function itself takes another function, the yield
function, as an argument. The iterator calls the yield function with
every value in the set.

You call s.All to get an iterator, and then you use for/range to loop
over all the elements in s. The for/range statement supports any
iterator, and this shows how easy that is to use.

func PrintAllElements[E comparable](s *Set[E]) {
    for v := range s.All() {
        fmt.Println(v)
    }
}


---


logrotate:

Do not use copytruncate!

The purpose of copytruncate is only for some poorly programmed
applications which do not handle the close and reopen of the log file,
and the logrotate config files does not send HUP to the applications.

The copytruncate option is useful when a program cannot be signaled to
close and reopen its log file (e.g., some older or poorly designed
applications). The downside, as noted, is that there might be a small
window of time between copying the log file and truncating it, during
which new log entries might be lost.
To avoid data loss with copytruncate:

Minimize the Window:
Use the shortest possible interval between log rotations. This reduces
the chance of losing data during the truncation process.

Use a Better Logging Approach:
If possible, modify the application to support log rotation natively or
use an application that supports re-opening log files. This avoids the
need for copytruncate.

Implement High Availability:
Use a more robust logging infrastructure or service that can handle such
operations more gracefully and ensure no data is lost.
For financial accounting data where data loss is unacceptable, the best
approach is to avoid copytruncate if feasible and configure your
application or system to handle log rotations more safely.

Truncate the original log file to zero size in place after creating a
copy, instead of moving the old log file and optionally creating a new
one. It can be used when some program cannot be told to close its
logfile and thus might continue writing (appending) to the previous log
file forever.
Note that there is a very small time slice between copying the file and
truncating it, so some logging data might be lost.

When you use logrotate with your application log files, it is important
to handle the log rotation process properly to avoid data loss. This
typically involves:

Sending a HUP Signal: In your logrotate configuration, you should
specify that a SIGHUP signal should be sent to your application after it
rotates its logs. This informs the application to close the current log
file and open a new one.

Handling the HUP Signal in Your Application: Your application needs to
be programmed to handle the SIGHUP signal so that it can perform the
necessary actions (like closing and reopening the log file) when it
receives this signal.

Example of a Logrotate Configuration

$ vi /etc/logrotate.d/my_application.conf

/path/to/my_application.log {
    daily
    rotate 7
    compress
    missingok
    notifempty
    create 0640 root adm
    postrotate
        /usr/bin/killall -HUP my_application
    endscript
}

$

## test the configuration for syntax errors
$ logrotate -d /etc/logrotate.d/my_application.conf

## force rotation for a specific config file
$ logrotate -f /etc/logrotate.d/my_application.conf


Example Code for Handling HUP Signal

C Example

You can use the signal function to register a handler for the HUP signal.

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

FILE *log_file;

void handle_hup(int sig) {
    // Close the current log file
    if (log_file) {
        fclose(log_file);
    }

    // Open a new log file (e.g., with a timestamp)
    log_file = fopen("my_application.log", "a");
    if (!log_file) {
        perror("Failed to open log file");
    }
}

int main() {
    // Initialize the log file
    log_file = fopen("my_application.log", "a");
    if (!log_file) {
        perror("Failed to open log file");
        return EXIT_FAILURE;
    }

    // Set up the signal handler for SIGHUP
    signal(SIGHUP, handle_hup);

    // Main application loop
    while (1) {
        fprintf(log_file, "Logging some data...\n");
        fflush(log_file);
        sleep(5); // Simulate doing work
    }

    // Clean up
    fclose(log_file);
    return EXIT_SUCCESS;
}

Go Example

In Go, you can use the os/signal package to listen for signals.

package main

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
)

var logFile *os.File

func handleHUP(sig os.Signal) {
    fmt.Println("Received HUP signal.")

    // Close the current log file
    if logFile != nil {
        logFile.Close()
    }

    // Open a new log file
    var err error
    logFile, err = os.OpenFile("my_application.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Printf("Error opening log file: %v\n", err)
    }
}

func main() {
    // Open the log file
    var err error
    logFile, err = os.OpenFile("my_application.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        fmt.Printf("Error opening log file: %v\n", err)
        return
    }

    // Set up signal handling for SIGHUP
    c := make(chan os.Signal, 1)
    signal.Notify(c, syscall.SIGHUP)

    go func() {
        for sig := range c {
            handleHUP(sig)
        }
    }()

    // Main application loop
    for {
        logFile.WriteString("Logging some data...\n")
        time.Sleep(5 * time.Second) // Simulate doing work
    }
}

Logrotate Configuration: Use the postrotate section to send a HUP signal
to your application.
Signal Handling: Implement signal handling in your application to close
and reopen the log files properly when a HUP signal is received.
The provided C and Go examples demonstrate how to do this effectively.


---


In the C language, when using logrotate on Linux, the new log entries
are typically written to the file with the original filename, regardless
of the options like create or copytruncate specified in the logrotate
configuration file.

For proper handling of log rotation, your application and logrotate
should have an agreement on how the log files are rotated and stored.
Logrotate can inform your application about the rotation by sending a
signal (e.g., SIGHUP) to your application process. Your application can
then handle this signal to close and reopen the log file to ensure it
writes to the new log file correctly. Additionally, your application
should be designed to handle log file rotation gracefully to avoid any
data loss or corruption during the rotation process.


logrotation configuration:

$ vi /etc/logrotate.d/my_application.conf
/path/to/my_application.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0640 root root
    sharedscripts
    postrotate
        kill -HUP <pid_of_my_app>
    endscript
}
$

## test the configuration for syntax errors
$ logrotate -d /etc/logrotate.d/my_application.conf

## force rotation for a specific config file
$ logrotate -f /etc/logrotate.d/my_application.conf


example in c:

$ vi my_application.c

#include <stdio.h>
#include <signal.h>
#include <pthread.h>

FILE *log_file;
pthread_mutex_t log_mutex;

void handle_signal(int signal) {
    if (signal == SIGHUP) {
        pthread_mutex_lock(&log_mutex);
        fclose(log_file); // Close current log file
        log_file = fopen("my_app.log", "a"); // Open new log file for writing
        pthread_mutex_unlock(&log_mutex);
    }
}

void log_message(const char *message) {
    pthread_mutex_lock(&log_mutex);
    if (log_file != NULL) {
        fprintf(log_file, "%s\n", message);
    }
    pthread_mutex_unlock(&log_mutex);
}

int main() {
    pthread_mutex_init(&log_mutex, NULL);
    signal(SIGHUP, handle_signal);

    // Open log file initially
    log_file = fopen("my_app.log", "a");

    // Continue running and logging...
    while (1) {
        log_message("This is a log entry");
        sleep(1); // Simulate work
    }

    fclose(log_file);
    pthread_mutex_destroy(&log_mutex);

    return 0;
}

$


example in golang:

$ vi my_application.go

package main

import (
	"log"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"
)

var (
	logFile    *os.File
	logMutex   sync.Mutex
	signalChan chan os.Signal
)

func handleSignals() {
	for sig := range signalChan {
		if sig == syscall.SIGHUP {
			logMutex.Lock()
			if logFile != nil {
				logFile.Close() // Close current log file
			}
			file, err := os.OpenFile("my_app.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0640)
			if err != nil {
				log.Printf("Failed to open log file: %v\n", err)
			} else {
				logFile = file // Open new log file for writing
			}
			logMutex.Unlock()
		}
	}
}

func logMessage(message string) {
	logMutex.Lock()
	if logFile != nil {
		logFile.WriteString(message + "\n")
	}
	logMutex.Unlock()
}

func main() {
	var err error
	logFile, err = os.OpenFile("my_app.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0640)
	if err != nil {
		log.Fatalf("Failed to open log file: %v\n", err)
	}
	defer logFile.Close()

	signalChan = make(chan os.Signal, 1)
	signal.Notify(signalChan, syscall.SIGHUP)

	go handleSignals()

	for {
		logMessage("This is a log entry")
		time.Sleep(1 * time.Second) // Simulate work
	}
}

$


---


// signal

// $ kill -HUP <pid>
// $ kill -HUP <pid>

func handlerHUP(sig os.Signal) {
    println("handlerHUP: ", sig == syscall.SIGHUP)
}

func main() {
    ch := make(chan os.Signal, 1)
    signal.Notify(ch, syscall.SIGHUP)
    done := make(chan struct{})

    go func() {
        for sig := range ch {
            handlerHUP(sig)
        }
        done <- struct{}{}
    }()

    //...

    println("awaiting SIGHUP")

    <-done
    println("exiting")
}

/*
$ go build && ./main
awaiting SIGHUP
handlerHUP:  true
handlerHUP:  true
^C
$
*/


---


















---


  </textarea>

</body>

</html>
