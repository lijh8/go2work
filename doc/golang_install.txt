
golang install


# golang mirror

$ vi ~/.profile
export PATH=$PATH:/usr/local/go/bin
go env -w GOSUMDB="sum.golang.google.cn"
go env -w GOPROXY="https://goproxy.io,https://goproxy.cn,direct"
$

$ source ~/.profile

# VSCode extension: golang.go
# it installs dependencies automatically with mirror
# it prompts to install delve dlv debugger
# it works with "Remote - SSH" (ms-vscode-remote.remote-ssh) to linux

# "dlv" command is not available.
# Run "go install -v github.com/go-delve/delve/cmd/dlv@latest" to install.
Installing 3 tools at /Users/ljh/go/bin
  gopls
  dlv
  staticcheck
Installing golang.org/x/tools/gopls@latest (/Users/ljh/go/bin/gopls)
Installing github.com/go-delve/delve/cmd/dlv@latest (/Users/ljh/go/bin/dlv)
Installing honnef.co/go/tools/cmd/staticcheck@latest (/Users/ljh/go/bin/staticcheck)
All tools successfully installed. You are ready to Go. :)


---


# Error loading workspace: You are outside of a module and outside of $GOPATH/src.
# should open workspace or module root dir in VSCode instead.
# these env var not needed since go1.19: GOPATH, GOBIN, GOROOT, GO111MODULE.


---


$ cd ~
$ ls
cgo  go.work  foo  main
$ find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
.
|____main
| |____go.mod
| |____main.go
|____go.work
|____foo
| |____go.mod
| |____bar
| | |____bar.go
| |____foo.go
|____cgo
| |____Makefile
| |____cgo.c
| |____libcgo.so
| |____cgo.h
$


---


$ cd ~
$ mkdir main; cd main;
$ go mod init example/main

$ cd ~
$ mkdir foo; cd foo;
$ go mod init example/foo
$ mkdir bar

$ cd ~
$ go work init main foo
$ go work use bar  # for adding additional modules


---


$ cd ~
$ cat go.work

go 1.23.0

use (
    ./foo
    ./foo/bar
)
$

$ cat main/go.mod
module example/main

go 1.19

require foo/bar v0.0.0
replace foo/bar => ../foo/bar
$

$ cat main/main.go

package main

/*
#cgo CFLAGS: -I../cgo
#cgo LDFLAGS: -L../cgo  -lcgo
#include "cgo.h"
*/
import "C"
import (
    "example/foo"
    "example/foo/bar"
    "fmt"
    "unsafe"
)

func main() {
    fmt.Println("main")
    foo.Foo()
    bar.Bar()

    // cgo: pass strings to and from C function
    // char *strncpy2(char *dest, const char *src, size_t n);

    buf := [32]byte{}
    buflen := len(buf)
    str := "hello"
    cs := C.CString(str)
    defer C.free(unsafe.Pointer(cs))

    C.strncpy2(
        (*C.char) (unsafe.Pointer (&buf)),
        cs,
        C.size_t(buflen) - 1)

    fmt.Println("cgo", string(buf[:]))

    // cgo: pass integers to and from C function
    // int *intcpy(int *dest, int src);

    a := 0;
    b := 123;

    C.intcpy(
        (*C.int) (unsafe.Pointer(&a)),
        C.int(b))

    fmt.Println("cgo", a)
}
$


---


https://golang.google.cn/cmd/cgo/ ,

These two call malloc to make copies free them after:
C.CString, C.CBytes,


---


$ cat foo/go.mod
module example/foo

go 1.19
$

$ cat foo/foo.go
package foo

import "fmt"

func Foo() {
    fmt.Println("Foo")
}
$

$ cat foo/bar/world.go
package bar

import "fmt"

func Bar() {
    fmt.Println("world")
}
$


---


$ cat cgo/cgo.c
#include <string.h>
#include "cgo.h"

char *strncpy2(char *dest, const char *src, size_t n)
{
    strncpy(dest, src, n);
    return dest;
}

int *intcpy(int *dest, int src)
{
    *dest = src;
    return dest;
}
$

$ cat cgo/cgo.h
#ifndef cgo_h
#define cgo_h

#include <stdio.h>
#include <stddef.h>

char *strncpy2(char *dest, const char *src, size_t n);

int *intcpy(int *dest, int src);

#endif
$

$ cat cgo/Makefile
# build shared library with -fPIC, -shared
CFLAGS   = -Wall -Wextra -g -std=c99 -fPIC # -O3  # CXXFLAGS for .cpp
LDFLAGS  = -shared # -L../foo
LDLIBS   = # -lfoo
CPPFLAGS = -MMD -MP # -I../foo
# CC     = $(CXX)  # link with CXX for .cpp

# target name is basename of one of the source files
cgo : $(patsubst %.c,%.o,$(wildcard *.c))  # .cpp
-include *.d
clean : ; -rm -fr *.o *.d
.PHONY : clean
$


---


$ cd ~/cgo
$ make
$ mv cgo libcgo.so

$ cd ~/main
$ go mod init example/foo
$ go mod tidy
$ go work init main foo
$ go work use foo

$ go run .
$ go build  # use module name from go.mod by default
$ ./main
$ go clean

$   LD_LIBRARY_PATH=../cgo/  go run .
$ DYLD_LIBRARY_PATH=../cgo/  go run .  # macOS


---


https://go.dev/ref/spec ,

A set of files sharing the same PackageName form the implementation of a package.
An implementation may require that all source files for a package inhabit the same directory.


---


https://go.dev/doc/modules/layout ,

A Go package can be split into multiple files,
all residing within the same directory,
All the files in the directory declare package modname.


---


https://golang.google.cn/doc/code ,

The module contains the packages in the directory containing
its go.mod file as well as subdirectories of that directory,
up to the next subdirectory containing another go.mod file (if any).


https://golang.google.cn/doc/modules/managing-source ,

Sourcing one module per repository.
You can maintain a repository that has a single module's source in it.
In this model, you place your go.mod file at the repository root,
with package subdirectories containing Go source beneath.

Sourcing multiple modules in a single repository.
Each subdirectory that is a module root directory must have its own go.mod file.


https://golang.google.cn/doc/modules/layout ,

Assuming this directory is uploaded to a GitHub repository
at github.com/someuser/modname, the module line in the go.mod file
should say module github.com/someuser/modname.


https://golang.google.cn/blog/using-go-modules ,

A module is a collection of Go packages stored in a file tree
with a go.mod file at its root.
The go.mod file defines the module's module path, which is also
the import path used for the root directory, and its dependency requirements,
which are the other modules needed for a successful build.

the go command enables the use of modules when the current directory
or any parent directory has a go.mod,

the directory contains a package, but not a module, because there is no go.mod file.

The go.mod file only appears in the root of the module.
Packages in subdirectories have import paths consisting of
the module path plus the path to the subdirectory.
For example, if we created a subdirectory world,
we would not need to (nor want to) run go mod init there.
The package would automatically be recognized as part of
the example.com/foo module, with import path example.com/foo/bar.


https://golang.google.cn/blog/migrating-to-go-modules ,

Your new go.mod file defines a canonical import path for your module,

Each module declares its module path in its go.mod file.
Each import statement that refers to a package within the module must
have the module path as a prefix of the package path.


---


package:

- all source files in a directory declare the same package name;
- subdirs are sub packages;
- go.mod turns a package into a module;
- module dir should be in go.work;
- module name in go.mod is used as import path;
- package name is used to reference exported functions or types;
- module name and package name diff:
    golang.go adds import alias same as package name;
- directory name and package namd diff:
    golang.go adds import alias same as package name;


module:

- dependencies;
- versioning;
- switch between local and online modules;
// https://golang.google.cn/wiki/Modules#can-i-work-entirely-outside-of-vcs-on-my-local-filesystem


$ cat go.mod
module main
go 1.23.0
require bar v0.0.0
replace bar => ../foo/bar
require foo/bar v0.0.0
replace foo/bar => ../foo/bar
require example.com/some/dependency v1.2.3
replace example.com/some/dependency => example.com/some/dependency v1.2.3
$


workspace:

- organize multiple modules;

use (
    ./main
    ./foo
    ./foo/bar
)


---


https://go.dev/doc/modules/layout ,

A basic Go package has all its code in the project's root directory.
The project consists of a single module, which consists of a single package.
The package name matches the last path component of the module name.

project-root-directory/
  go.mod
  modname.go
  modname_test.go

Assuming this directory is uploaded to a GitHub repository
at github.com/someuser/modname, the module line in the go.mod file
should say module github.com/someuser/modname.

The code in modname.go declares the package with:
  package modname

Users can then rely on this package by import-ing it in their Go code with:

  import "github.com/someuser/modname"


---


The layout for a command with supporting packages in an internal directory is very similar,
except that the file(s) in the root directory declare package main.


Multiple packages

A module can consist of multiple importable packages;
each package has its own directory, and can be structured hierarchically.

The modname package resides in the root directory,
declares package modname and can be imported by users with:
  import "github.com/someuser/modname"

Sub-packages can be imported by users as follows:
  import "github.com/someuser/modname/auth"
  import "github.com/someuser/modname/auth/token"
  import "github.com/someuser/modname/hash"


---


In Go, the versioning for modules is indeed managed by utilizing
the `go.mod` file, which includes references to other modules along with
their respective version numbers. The version number specified
in `go.mod` is commonly associated with a particular release or tag
within a version control system like Git.

When you specify a module in a `go.mod` file, you include the modules
path and the version you want to use. For example:

```go
module example.com/greetings

require example.com/somepackage v1.2.3
```

In this case, the `v1.2.3` is a version tag that specifically refers to
a release within the version control system, such as a tag in Git.
The versioning and the associated commits are managed outside of
the Go toolchain within the version control system.

So, although Go itself doesnt define the version number directly,
it relies on external version control systems like Git to manage these
versions and track the associated changes.


---


import path:

import example/foo
import example/foo/bar

importing root package := module path
importing subpackage   := module path + subdirectory

module name:
go mod init example/foo
go.mod: module example/foo

subpackage:
example/foo/bar


---


VSCode golang debugging with dlv / delve:

__debug_bin: error while loading shared libraries: xxx.so:
cannot open shared object file: No such file or directory

VSCode settings:

"go.toolsEnvVars": {
    "LD_LIBRARY_PATH": "/path/to/lib",
  "DYLD_LIBRARY_PATH": "/path/to/lib",  // macOS
},


---


# command line debug

$ ls /usr/local/go/bin/
go  gofmt
$ ls ~/go/bin/
dlv  gomodifytags  goplay  gopls  gotests  impl  staticcheck
$

$ cd ~/foo_go
$ ls
go.mod  main.go
$

https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_debug.md ,
https://github.com/go-delve/delve/blob/master/Documentation/usage/dlv_exec.md ,

$ dlv debug        # compile and debug main package in current directory

$ dlv exec ./main  # debug precompiled binary

(dlv) restart
(dlv) break main.go:57
Breakpoint 1 set at 0x49f66f for main.string_search() ./main.go:57
(dlv) breakpoints
(dlv) toggle
(dlv) clear 1
(dlv) continue
> main.string_search() ./main.go:57 (hits goroutine(1):1 total:1) (PC: 0x49f66f)
    55:
=>  57: func string_search() {
    58:    str := "aaaXXaaaYYaaa"

(dlv) print max
(dlv) next
(dlv) step
(dlv) stepout
(dlv) stack
(dlv) bt


---


https://golang.google.cn/doc/gdb ,

## strip or omit the debug information
$ go build -ldflags="-w -s"

## disable optimizations, dlv creates building with these options for debug
$ go build -gcflags=all="-N -l"


---


type T struct {
  name string
  num int
}

//strstr2, find substring
func strstr2() {
  haystack := "aaaYYaaaYYaaa"
  needle := "aaa"

  for i := 0; i != len(haystack); i++ {
    r := strings.Index(haystack[i:], needle)
    if r != -1 {
      i += r
      log.Println(i)
    } else {
      break;
    }
  }
}

func sortSearch() {
  haystack := []T{
    {"aaa", 111},
    {"bbb", 222}, //dup
    {"bbb", 222}, //dup
    {"ccc", 333},
  }
  needle := T{"bbb", 222}

  index := sort.Search(len(haystack), func(i int) bool {
    //asc >=
    //desc <=
    if haystack[i].name >= needle.name ||
      haystack[i].name == needle.name &&
      haystack[i].num >= needle.num {
        return true;
    }

    return false
  })

  log.Println(index)

  for i := index; i < len(haystack); i++ {
    if haystack[i] == needle {
      log.Println(i, haystack[i])
    } else {
      break
    }
  }
}

func sortFind() {
  log.SetFlags(log.LstdFlags | log.Llongfile)

  haystack := []T{
    {"aaa", 111},
    {"bbb", 222}, //dup
    {"bbb", 222}, //dup
    {"ccc", 333},
  }
  needle := T{"bbb", 222}

  i, found := sort.Find(len(haystack), func(i int) int {
    //asc -1 0 1
    //desc 1 0 -1
    if needle.name < haystack[i].name ||
      needle.name == haystack[i].name &&
      needle.num < haystack[i].num {
        return -1
    } else

    if needle == haystack[i] {
      return 0
    } else

    if needle.name > haystack[i].name ||
      needle.name == haystack[i].name &&
      needle.num > haystack[i].num {
        return 1
    }

    return 9 // do i have to
  })

  log.Println(found, i)

  for i := i; found && i != len(haystack); i++ {
    if haystack[i] == needle {
      log.Println(i, haystack[i])
    } else {
      break
    }
  }
}


---


// https://pkg.go.dev/fmt ,
// print format

// print value and type
var i = 123
fmt.Printf("%v, %T\n", i, i)


---


// log with utc time, filename, line number,
// log to both standard output and disk file in its executable path.

package log2

func InitLog(filename string) (*os.File, error) {
    exePath, err := os.Executable()
    if err != nil {
        return nil, err
    }

    realPath, err := filepath.EvalSymlinks(exePath)
    if err != nil {
        return nil, err
    }

    logpath := filepath.Dir(realPath)
    logpath = filepath.Join(logpath, filename)
    logfd, err := os.OpenFile(logpath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return nil, err
    }
    multiWriter := io.MultiWriter(logfd, os.Stdout)
    log.SetOutput(multiWriter)
    log.SetPrefix("UTC ")
    log.SetFlags(log.LUTC | log.LstdFlags | log.Lshortfile)
    return logfd, nil
}

/*
func main() {
    logfile := "logfile.log"
    logfd, err := log2.InitLog(logfile) // log2 init
    if err == nil {
        defer logfd.Close()
    }

    log.Println("aaa") // log as usual
    log.Println("bbb")
}
*/


---


// golang print log filename, line number, function name

func Println2(args ...any) {
    pc, file, line, ok := runtime.Caller(1)
    if !ok {
        file, line = "unknown", 0
    }
    fn := runtime.FuncForPC(pc)
    fmt.Println(append([]any{filepath.Base(file), ":", line, ":", fn.Name(), ":"}, args...)...)
}

func main() {
    fmt.Println("aaa", 111)
    println("bbb", 222)
}


---


type T struct {
    num int
}

// non interface:

// method can take value of pointer receiver
// receiver can be value of pointer
// pointer receiver can write changes to receiver

func (t T) f1() {
//func (t *T) f1() {
    t.num *= 2
}


// interface:

// receiver must match
// value receiver takes value receiver
// pointer receiver takes pointer receiver
// pointer receiver can write changes to receiver

type I2 interface {
    f2()
}

type I3 interface {
    f3()
}

func (t T) f2() {
    t.num *= 2
}

func (t *T) f3() {
    t.num *= 2
}

func main() {
    t := T{2}
    t.f1()
    println(t)

    p := &T{2}
    p.f1()
    println(p)

    var i2 I2 = T{2}
    i2.f2()
    println(i2)

    var i3 I3 = &T{2}
    i3.f3()
    println(i3)
}


---


example 1:

// https://golang.google.cn/tour/concurrency/5 ,

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func read(c, quit chan int) {
    for i := 0; i < 5; i++ {
        fmt.Println(<-c)
    }
    quit <- 0
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go read(c, quit)
    fibonacci(c, quit)
}

example 2:

// https://golang.google.cn/tour/concurrency/5 ,

func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func read(c, quit chan int) {
    for i := 0; i < 5; i++ {
        fmt.Println(<-c)
    }
    quit <- 0
}

func main() {
    c := make(chan int)
    quit := make(chan int)
    go fibonacci(c, quit)
    read(c, quit)
}


---


// Common Mistakes

func main() {
    fun1()
    fun2()
}

// https://github.com/golang/go/wiki/CommonMistakes
// Using reference to loop iterator variable

func fun1() {
    var out []*int
    for i := 0; i < 3; i++ {
        i := i //add new variable
        out = append(out, &i)
    }
    fmt.Println("Values:", *out[0], *out[1], *out[2])
    fmt.Println("Addresses:", out[0], out[1], out[2])
}

// https://golang.google.cn/doc/faq
// What happens with closures running as goroutines?

func fun2() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func(v string) { //add parameter
            fmt.Println(v)
            done <- true
        }(v) //pass argument
    }

    // wait for all goroutines to complete before exiting
    for _ = range values {
        <-done
    }
}


---


func main() {
    for i := 0; i < 3; i++ {

        // https://go.dev/wiki/CommonMistakes ,
        // Using reference to loop iterator variable ,
        // Fixed in: https://golang.google.cn/blog/loopvar-preview ,

        // i := i // Copy i into a new variable, not anymore. Fixed

        println(i)
    }

    // https://go.dev/wiki/CommonMistakes ,
    // Using goroutines on loop iterator variables ,
    // Fixed in: https://golang.google.cn/blog/loopvar-preview ,

    // mistake
    values := []int{1, 2, 3}
    for _, val := range values {
        go func() {
            println(val)
        }()
    }

    // temporary fix
    for _, val := range values {
        go func(val interface{}) { // val, not anymore. Fixed
            println(val)
        }(val) // val, not anymore. Fixed
    }
}


---


// https://golang.google.cn/doc/effective_go#redeclaration ,
// Redeclaration and reassignment

// there is at least one new other variable that is created by the declaration.
// this unusual property is pure pragmatism, making it easy to use a single err value.

func main() {
    a, err := strconv.Atoi("42")
    if err == nil {
        println(a);
    }

    // there is at least a new other variables `b` on left side of :=
    b, err := strconv.Atoi("42")
    if err == nil {
        println(b);
    }
}


---


// golang read text file line by line ,

func main() {
    // Open the text file
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    // Create a new Scanner to read from the file
    scanner := bufio.NewScanner(file)

    // Read the file line by line
    for scanner.Scan() {
        line := scanner.Text()
        fmt.Println(line)
    }

    // Check for any errors during scanning
    if err := scanner.Err(); err != nil {
        fmt.Println("Error scanning file:", err)
    }
}


---


// command line arguments

func main() {

    argsWithProg := os.Args
    argsWithoutProg := os.Args[1:]

    arg := os.Args[3]

    fmt.Println(argsWithProg)
    fmt.Println(argsWithoutProg)
    fmt.Println(arg)
}


// standard input and output

func main() {
    reader := bufio.NewReader(os.Stdin)

    fmt.Print("Enter a line: ")

    line, err := reader.ReadString('\n')
    if err != nil {
        fmt.Println("Error reading input:", err)
        return
    }

    fmt.Println("You entered:", line)
}


---


// reverse of slices.Index
func ReverseIndex[S ~[]E, E comparable](s S, v E) int {
    for i := len(s) - 1; i >= 0; i-- {
        if s[i] == v {
            return i
        }
    }
    return -1
}

// https://golang.google.cn/pkg/strings/#Index ,

// strings.Index for substring or single character ,
// slices.Index for single element,
// slices.Sort, .BinarySearch,

Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.

func main() {
    fmt.Println(strings.Index("chicken", "ken"))
    fmt.Println(strings.Index("chicken", "dmr"))
}

func main() {
    fmt.Println(strings.Index("chicken", "dmr"))
    fmt.Println(strings.Index("chicken", "ken"))
    fmt.Println(strings.Index("chicken"[4:], "ken")) // search in range
    fmt.Println(strings.Index("chicken"[4:5], "ken")) // search in range
    fmt.Println(strings.Index("chicken"[5:], "ken")) // search in range
}

// https://golang.google.cn/pkg/slices/#Index ,

func Index[S ~[]E, E comparable](s S, v E) int
Index returns the index of the first occurrence of v in s, or -1 if not present.
(v in s, value in slice)

func main() {
    numbers := []int{0, 42, 8}
    fmt.Println(slices.Index(numbers, 8))
    fmt.Println(slices.Index(numbers, 7))
}

func main() {
    numbers := []int{0, 42, 8, 10, 20}
    fmt.Println(slices.Index(numbers, 8))
    fmt.Println(slices.Index(numbers[3:], 8)) // search in range
    fmt.Println(slices.Index(numbers[:2], 8)) // search in range
}

// https://golang.google.cn/pkg/slices/#IndexFunc ,

IndexFunc returns the first index i satisfying f(s[i]), or -1 if none do.

func main() {
    numbers := []int{0, 42, -10, 8}
    i := slices.IndexFunc(numbers, func(n int) bool {
        return n < 0
    })
    fmt.Println("First negative at index", i)
}

// https://golang.google.cn/pkg/slices/#Sort ,

func main() {
    smallInts := []int8{0, 42, -10, 8}
    slices.Sort(smallInts)
    fmt.Println(smallInts)
}

// https://golang.google.cn/pkg/slices/#SortFunc ,

// Example (MultiField)

func main() {
    type Person struct {
        Name string
        Age  int
    }
    people := []Person{
        {"Gopher", 13},
        {"Alice", 55},
        {"Bob", 24},
        {"Alice", 20},
    }
    slices.SortFunc(people, func(a, b Person) int {
        if n := cmp.Compare(a.Name, b.Name); n != 0 {
            return n
        }
        // If names are equal, order by age
        return cmp.Compare(a.Age, b.Age)
    })
    fmt.Println(people)
}

// https://golang.google.cn/pkg/slices/#BinarySearch ,

The slice must be sorted in increasing order ,

func main() {
    names := []string{"Alice", "Bob", "Vera"}
    n, found := slices.BinarySearch(names, "Vera")
    fmt.Println("Vera:", n, found)
    n, found = slices.BinarySearch(names, "Bill")
    fmt.Println("Bill:", n, found)
}

// https://golang.google.cn/pkg/slices/#BinarySearchFunc ,

The slice must be sorted in increasing order ,

func main() {
    type Person struct {
        Name string
        Age  int
    }
    people := []Person{
        {"Alice", 55},
        {"Bob", 24},
        {"Gopher", 13},
    }
    n, found := slices.BinarySearchFunc(people, Person{"Bob", 0}, func(a, b Person) int {
        return cmp.Compare(a.Name, b.Name)
    })
    fmt.Println("Bob:", n, found)
}


---


https://go.dev/blog/slices-intro#growing-slices-the-copy-and-append-functions ,

Growing slices (the copy and append functions)

To increase the capacity of a slice one must create a new,
larger slice and copy the contents of the original slice into it.
This technique is how dynamic array implementations from other languages
work behind the scenes. The next example doubles the capacity of s by
making a new slice, t, copying the contents of s into t,
and then assigning the slice value t to s


---


https://go.dev/ref/spec ,

The iteration order over maps is not specified and is not guaranteed to
be the same from one iteration to the next.

https://go.dev/blog/maps#iteration-order ,

Iteration order

When iterating over a map with a range loop, the iteration order is not
specified and is not guaranteed to be the same from one iteration to the
next. If you require a stable iteration order you must maintain a
separate data structure that specifies that order. This example uses a
separate sorted slice of keys to print a map[int]string in key order:

var m map[int]string
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println("Key:", k, "Value:", m[k])
}


---


// check integer overflow underflow wrap around

func main() {
    // MaxUint64:18446744073709551615,
    // MaxInt64 : 9223372036854775807,
    // MinInt64 :-9223372036854775808,

    var a uint64 = 18446744073709551615
    var b int64 =   9223372036854775807
    var c int64 =  -9223372036854775808
    var incr = 1 // 10

    // a -= 1 // a--
    if math.MaxUint64 - a < uint64(incr) {
        fmt.Println("err: a too large", a + uint64(incr))
    }

    // b -= 1 // b--
    if math.MaxInt64 - b < int64(incr) {
        fmt.Println("err: b too large", b + int64(incr))
    }

    // c += 1 // c++
    if math.MinInt64 + int64(incr) > c {
        fmt.Println("err: c too little", c - int64(incr))
    }
}


---


// /usr/local/go/src/builtin/builtin.go
type error interface {
    Error() string
}

// /usr/local/go/src/errors/errors.go
func New(text string) error {
    return &errorString{text} // ok

    // return errorString{text} // error

    // cannot use errorString{â€¦} (value of type errorString) as error value in return statement:
    // errorString does not implement error (method Error has pointer receiver)
}

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}


---


// https://github.com/golang/vscode-go/wiki/debugging ,
// .vscode/launch.json

{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Debug",
            "type": "go",
            "request": "launch",
            "mode": "debug", // main package
            "program": "${fileDirname}", // main package
            // "mode": "exec", // executable
            // "program": "${fileDirname}/${fileBasenameNoExtension}", // executable
            "args": [], //
            // "args": ["12345"], // $ ./server <port>
            // "args": ["192.168.1.3", "12345", "clientABC"], // $ ./client <serverIP> <port> <clientTag>
            "env": {
                "LD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
                "DYLD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
            },
            "cwd": "${fileDirname}",
            "console": "integratedTerminal",
            "preLaunchTask": "debugTask",
        },

        {
            "name": "Release",
            "type": "go",
            "request": "launch",
            "mode": "debug", // main package
            "program": "${fileDirname}", // main package
            // "mode": "exec", // executable
            // "program": "${fileDirname}/${fileBasenameNoExtension}", // executable
            "args": [], //
            // "args": ["12345"], // $ ./server <port>
            // "args": ["192.168.1.3", "12345", "clientABC"], // $ ./client <serverIP> <port> <clientTag>
            "env": {
                "LD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
                "DYLD_LIBRARY_PATH": "${workspaceFolder}/src/foo",
            },
            "cwd": "${fileDirname}",
            "console": "integratedTerminal",
            "preLaunchTask": "releaseTask",
        }
    ]
}

// https://code.visualstudio.com/Docs/editor/tasks ,
// .vscode/tasks.json

{
    "tasks": [
        {
            "type": "shell",
            "label": "debugTask",
            "command": "go",
            "args": ["build", "-gcflags=all=-N -l"], // disable optimizations
            // "args": ["build"],
            // "args": ["build", "-ldflags=-w -s"], // strip or omit the debug information
            "options": {
                // "cwd": "${workspaceFolder}/src",
                "cwd": "${fileDirname}",
            },
        },

        {
            "type": "shell",
            "label": "releaseTask",
            "command": "go",
            // "args": ["build", "-gcflags=all=-N -l"], // disable optimizations
            // "args": ["build"],
            "args": ["build", "-ldflags=-w -s"], // strip or omit the debug information
            "options": {
                // "cwd": "${workspaceFolder}/src",
                "cwd": "${fileDirname}",
            },
        }
    ],
    "version": "2.0.0",
}


---


// slice, array, string,

func main() {
	{
		a := [3]int{1, 2, 3}
		b := a[:] // ok, slice
		b[0] = 100
		fmt.Println(a, b)
	}

	{
		a := "abc"
		b := []rune(a) // ok, slice,
		b[0] = 'A'
		fmt.Println(a, string(b))
	}
}


---


package tuple2

import (
    "cmp"
    "reflect"
)

func Compare(a, b []any) (int, bool) {
    if len(a) != len(b) {
        return 0, false
    }

    for i := range a {
        if a[i] == nil || b[i] == nil {
            return 0, false
        }

        if _, boolean := a[i].(bool); boolean {
            return 0, false
        }
        if _, boolean := b[i].(bool); boolean {
            return 0, false
        }

        if a, b := reflect.TypeOf(a[i]), reflect.TypeOf(b[i]); a != b {
            return 0, false
        }

        if a, aOk := a[i].(string); aOk {
            if b, bOk := b[i].(string); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].(int); aOk {
            if b, bOk := b[i].(int); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].(float64); aOk {
            if b, bOk := b[i].(float64); bOk {
                if c := cmp.Compare(a, b); c != 0 {
                    return c, true
                }
            }
        }

        if a, aOk := a[i].([]any); aOk {
            if b, bOk := b[i].([]any); bOk {
                if c, ok := Compare(a, b); ok && c != 0 {
                    return c, true
                } else if !ok {
                    return 0, false
                }
            }
        }
    }
    return 0, true
}

/*
func main() {
    a := []any{"abc", 123, 3.14}
    b := []any{"abc", 123, 3.14}
    c, ok := tuple2.Compare(a, b)
    fmt.Println(c, ok)
}
*/


---


In VSCode with golang.go extension, start compile and debug
with F5 without launch.json, tasks.json,
when build fails, the go build command and options shows in debug console.

Build Error: go build -o /path/__debug_bin3374052179 -gcflags all=-N -l .
./main.go:13:30: syntax error: unexpected true in composite literal;


---


error: no new variables on left side of := ,
reason:
    see this error when variable name is same as parameter name.

warning: func aCmp222 is unused (U1000) ,
reason:
    function name starts with lower case,
    it is not used in other exported function in same package,
    it also has no chance to be used outside the package,
    because its name starts with lower case.


---


// builtin print can not handle data of interface type,
// fmt.Println can help,
// log to disk file with log.Println,

var a any = "aaa"
va := reflect.ValueOf(a)
println(va) // illegal types for operand: print, reflect.Value (compile)
fmt.Println(va)


---


// generics

// concrete type as type constraint for type parameter
func f1[T string](name T) {

}

// ~T means all types whose underlying type is string
func f2[T ~string](name T) {

}

// T | T  means union type set
func f3[T ~string | ~int | float64](name T) {

}

func main() {
    f1("abc")
    f2("abc")

    f3("abc")
    f3(123)
}


---


func main() {
    ch := make(chan int, 3)
    done := make(chan struct{})

    //sending
    var sending = func() {
        for i := 0; i <= 5; i++ {
            select {
            case ch <- i:
                fmt.Printf("sending:%d, ", i)
            default:
                // block on buffered channel is full, unless there is a receiver
                fmt.Printf("blocking, len:%d, cap:%d, ", len(ch), cap(ch))
            }
        }

        close(ch) // for range statement in receiver
        done <- struct{}{} // for synchronization
    }

    //receiving
    var receiving = func() {
        // turn of this range loop to see the block when channel is full
        /*
        for i := range ch { // receiving, same as: <-ch
            fmt.Printf("receiving, ch:%d, len:%d, cap:%d, ", i, len(ch), cap(ch))
        }
        */

        done <- struct{}{} // for synchronization
    }

    go sending()
    go receiving()

    <-done // wait for sending background goroutine
    <-done // wait for receiving background goroutine
}


---


func main() {
    const MAX = 3
    done := make(chan any)

    go func() {
        for i := 0; i != MAX; i++ {
            fmt.Printf("func1:%d, ", i)
        }
        done <- nil
    }()

    go func() {
        for i := 0; i != MAX; i++ {
            fmt.Printf("func2:%d, ", i)
        }
        done <- nil
    }()

    for i := 0; i != MAX; i++ {
        fmt.Printf("main:%d, ", i)
    }

    // do synchronization and wait for background goroutine

    <-done // one for background goroutine func1
    <-done // one for background goroutine func2
}


---


A Tour of Go:
https://golang.google.cn/tour/concurrency/2 ,

By default, sends and receives block until the other side is ready.
This allows goroutines to synchronize without explicit locks or condition variables.

https://golang.google.cn/tour/concurrency/3 ,

Sends to a buffered channel block only when the buffer is full.
Receives block when the buffer is empty.


---


The Go Memory Model:
https://golang.google.cn/ref/mem ,

1. A send on a channel is synchronized before the completion of the
    corresponding receive from that channel.

2. A receive from an unbuffered channel is synchronized before the
    completion of the corresponding send on that channel.

3. The closing of a channel is synchronized before a receive that
    returns a zero value because the channel is closed.

4. The kth receive on a channel with capacity C is synchronized before the
    completion of the k+Cth send from that channel completes.


explanation:

1. for unbuffered and buffered channel, a send blocks the current goroutine;
    A send operation establishes a happens-before relationship with the
    corresponding receive operation in terms of memory visibility.
    This means that the send must occur before the receive for the value to
    be seen on the channel,
    regardless of whether the channel is buffered or unbuffered.

2. for unbuffered channel, a receive also blocks the current goroutine;
    An unbuffered channel has a size and capacity of zero,
    meaning it has no buffer to store values.
    Communication over an unbuffered channel is synchronous,
    requiring both the send and receive goroutines to be ready simultaneously
    for data transfer to occur.

3. range and close, https://golang.google.cn/tour/concurrency/4 ,
    Closing is only necessary when the receiver must be told there are
    no more values coming, such as to terminate a range loop.

4. A buffered channel is of capacity of ie. 3, if send four values to it,
    the channel is full, the forth send will blocks and waits for a receive before it.
    if there is no corresponding receive, it is deadlock and it panics.

    send to full buffered channel causes deadlock;
    receive from empty bufferec channel causes deadlock;

    A send places a value into buffered channel;
    A receive removes a value from buffered channel;


---


Unbuffered Channels:
Ensure direct synchronization between sends and receives,
each send blocks until it is matched with a receive.

Buffered Channels:
Allow multiple sends up to capacity without immediate receives,
but will block when the buffer is full until a receive frees up space.


---


The Go Programming Language, by Kernighan & Donovan,

8.4:
Channels support a third operation, close, which sets a flag indicating
that no more values will ever be sent on this channel; subsequent
attempts to send will panic. Receive operations on a

8.4.1:
A send operation on an unbuffered channel blocks the sending goroutine
until another goroutine executes a corresponding receive on the same
channel, at which point the value is transmitted and both goroutines may
continue.

Conversely, if the receive operation was attempted first, the
receiving goroutine is blocked until another goroutine performs a send
on the same channel.

8.4.4:
Unbuffered channels give stronger synchronization guarantees because
every send operation is synchronized with its corresponding receive;


---


https://golang.google.cn/ref/mem ,

// A send on a channel is synchronized before the completion of the
// corresponding receive from that channel.

// var c = make(chan int, 10) // buffered, ok
var c = make(chan int) // unbuffered, ok
var a string

func f() {
    a = "hello, world"
    c <- 0
}

func main() {
    go f()
    <-c
    print(a)
}

// is guaranteed to print "hello, world".
// The write to a is sequenced before the send on c,
// which is synchronized before the corresponding receive on c completes,
// which is sequenced before the print.


---


https://golang.google.cn/ref/mem ,

// A receive from an unbuffered channel is synchronized before the
// completion of the corresponding send on that channel.

// original

var c = make(chan int)
var a string

func f() {
    a = "hello, world"
    <-c
}

func main() {
    go f()
    c <- 0
    print(a)
}

// revised

// var c = make(chan int)     // ok
var c = make(chan int, 10) // no, buffered
var a string
var done chan any = make(chan any)

func f() {
    a = "hello, world"

    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c

    done <- nil
}

func main() {
    go f()
    c <- 0
    c <- 0 // try to send one more, and see len in f()

    <-done // send to this in f() happends before this line

    print(a)

}

// output:
// len: 2 , cap: 10
// hello, world

1. send to c in main() is sequenced before receive in f(),
    so len(c) in f() reports count of values sent in main().

2. add channel `done` and send to it in f(),
    to make sure the assignment to a happens before main().


---


https://golang.google.cn/ref/mem ,

// The kth receive on a channel with capacity C is synchronized before
// the completion of the k+Cth send from that channel completes.

// var c = make(chan int)
var c = make(chan int, 3)
var a string

func f() {
    a = "hello, world"
    <-c
}

func main() {
    go f()
    c <- 0
    c <- 0
    c <- 0

    // this send is beyond cap(c),
    // it blocks and waits for a receive before it.
    c <- 0

    print(a)
}


---


// fatal error: all goroutines are asleep - deadlock!
// goroutine 1 [chan receive]:

/*
the term "asleep" is synonymous with "blocked" or "waiting indefinitely."
Specifically, it means that all active goroutines in the program are
waiting for something that will never happen, leading to a deadlock.

golang panics and terminates program explicitly,
let programmer to identify the issue.
*/

var c = make(chan int, 3)
var a string
var done = make(chan any)

func f() {
    a = "hello, world"
    println(<-c, len(c), cap(c))
    println(<-c, len(c), cap(c)) // error, receive from empty channel

    done <- nil
}

func main() {
    go f()
    c <- 20

    <-done

    print(a)
}


---


// fatal error: all goroutines are asleep - deadlock!
// goroutine 1 [chan send]:

var c = make(chan int, 3)
var a string
var done = make(chan any)

func f() {
    a = "hello, world"
    <-c

    done <- nil
}

func main() {
    go f()
    c <- 0
    c <- 0
    c <- 0
    c <- 0
    c <- 0 // error, send to full buffered channel

    <-done

    print(a)
}


---

// modification

// var c = make(chan int) // ok
var c = make(chan int, 10) // no, buffered
var a string

var done chan any = make(chan any)

func f() {
    a = "hello, world"

    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c

    done <- nil
}

func main() {
    go f()
    // c <- 0 // try comment out this line

    <-done

    print(a)

}

// try commenting all sends to c in main(),
// add channel `done` and send to it in f(),
// the receive from c in f() causes deadlock, because c is empty.


---


// modification, again

// var c = make(chan int) // ok
var c = make(chan int, 10) // no, buffered
var a string

var done chan any = make(chan any)

func f() {
    a = "hello, world"
    println("len:", len(c), ",", "cap:", cap(c)) // values in c is sent in main()
    <-c
    done <- nil
}

func main() {
    go f()
    <-done
    c <- 0 // try comment out this line
    print(a)

}

// try move ` <-done ` before ` <-c ` in main() to see deadlock


---


func main() {
    // synchronize two goroutines with two channels
    // let the code in the first goroutine execute first
    const MAX = 6
    cA := make(chan any)
    cB := make(chan any)
    done := make(chan any)

    go func() {
        for i := 0; i < MAX; i++ {
            fmt.Println("a", i)
            cA <- nil
            <-cB
        }
        done <- nil
    }()

    go func() {
        for i := 0; i < MAX; i++ {
            <-cA
            fmt.Println("b", i)
            cB <- nil
        }
        done <- nil
    }()

    <-done
    <-done
}

func main() {
    // synchronize two goroutines with two channels
    // let the code in the second goroutine execute first
    const MAX = 6
    cA := make(chan any)
    cB := make(chan any)
    done := make(chan any)

    go func() {
        for i := 0; i < MAX; i++ {
            <-cA
            fmt.Println("a", i)
            cB <- nil
        }
        done <- nil
    }()

    go func() {
        for i := 0; i < MAX; i++ {
            fmt.Println("b", i)
            cA <- nil
            <-cB
        }
        done <- nil
    }()

    <-done
    <-done
}


---


func main() {
    const CAP = 3 // unbuffered: 0; buffered: 1,2,3,.., etc.
    const LEN = CAP + 2
    ch := make(chan any, CAP)
    done := make(chan any)

    go func() {
        for i := 0; i < LEN; i++ {
            select {
            case ch <- nil: // comment this to see block on empty
            // case <-ch: // comment this to see block on full
            default:
                log.Printf("block, i:%d, len:%d; cap:%d", i, len(ch), cap(ch))
            }
        }
        done <- nil
    }()

    <-done
}


---

